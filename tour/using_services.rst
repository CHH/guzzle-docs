=======================================
Consuming web services
=======================================

.. highlight:: php

Guzzle's awesome HTTP support provides the raw materials needed to build robust web service clients.  Guzzle's service layer provides the glue needed to bring it all together.

Using a Client object
---------------------

The Guzzle ``Guzzle\Service\Client`` object can be used directly with a simple web service.  Robust web service clients should interact with a web service using command objects, but if you want to quickly interact with a web service, you can create a client and build your HTTP requests manually.

In the following example, we are interacting with the Unfuddle API and issuing a GET request to retrieve a listing of tickets in the 123 project::

    <?php

    use Guzzle\Service\Client;

    $client = new Client('https://mydomain.unfuddle.com/api/v1');
    $request = $client->get('projects/{{project_id}}/tickets', array(
        'project_id' => '123'
    ));

    $request->setAuth('myusername', 'mypassword');
    $response = $request->send();

Notice that the URI provided to the client's ``get`` method is relative.  The path in the URI is also relative.  Relative paths will add to the path of the base URL of the client-- so in the example above, the path of the base URL is ``/api/v1``, the relative path is ``projects/123/tickets``, and the URL will ultimately become ``https://mydomain.unfuddle.com/api/v1/projects/123/tickets``.  If a relative path and a query string are provided, then the relative path will be appended to the base URL path, and the query string provided will be merged into the query string of the base URL.  If an absolute path is provided (e.g. ``/path/to/something``), then the path specified in the base URL of the client will be replaced with the absolute path, and the query string provided will replace the query string of the base URL.  If an absolute URL is provided (e.g. ``http://www.test.com/path``), then the request will completely use the absolute URL as-is without merging in any of the URL parts specified in the base URL.

Similar to `RestTemplates <http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/remoting.html>`_ in Spring, templates can be specified in the client's ``get``, ``head``, ``delete``, ``post``, ``put`` and ``options`` methods, which allow placeholders to be specified in the the request template that will be overwritten with an array of configuration data referenced by key.

All requests in the above client would need `basic HTTP authorization <http://www.ietf.org/rfc/rfc2617.txt>`_ added after they are created.  You can automate this and add the authorization header to all requests generated by the client by adding a custom event to the client's event manager.  Another annoyance you can solve with Guzzle's event system is automatically creating SimpleXMLElement objects for a response when the content type is ``application/xml``.  Here's an example of creating a very simple Unfuddle client that lists the email addresses of everyone in your project (note: Guzzle has a robust Unfuddle client-- this is just an example)::

    <?php

    $client = new Client('https://mydomain.unfuddle.com/api/v1');
    $client->getEventManager()->attach(function($subject, $event, $context) {
        if ($event == 'request.create') {
            $context->setAuth('myusername', 'mypassword');
        } else if ($event == 'request.complete' && $context->isContentType('application/xml')) {
            // Hack the getInfo/setInfo methods
            $context->setInfo(
                array_merge(array(
                    'xml' => new \SimpleXMLElement($context->getBody(true)))
                ), $context->getInfo()
            );
        }
    });

    $response = $client->get('projects/{{project_id}}/people', array(
        'project_id' => '1'
    ))->send();

    foreach ($response->getInfo('xml')->person as $person) {
        echo $person->email . "\n";
    }

Requests can be created from a client using the following methods of ``Guzzle\Service\Client``:

=============  ==========================================  =============================================
Method         Arguments                                   Returns
=============  ==========================================  =============================================
get            ``($uri = null, $inject = null)``           ``Guzzle\Http\Message\Request``
head           ``($uri = null, $inject = null)``           ``Guzzle\Http\Message\Request``
delete         ``($uri = null, $inject = null)``           ``Guzzle\Http\Message\Request``
put            ``($uri = null, $inject = null)``           ``Guzzle\Http\Message\EntityEnclosingRequest``
post           ``($uri = null, $inject = null)``           ``Guzzle\Http\Message\EntityEnclosingRequest``
options        ``($uri = null, $inject = null)``           ``Guzzle\Http\Message\Request``
createRequest  ``($method, $uri = null, $inject = null)``  ``Guzzle\Http\Message\RequestInterface``
=============  ==========================================  =============================================

Command based web service clients
---------------------------------

Command based web service clients help to hide the underlying implementation of an API by following the `command pattern <http://en.wikipedia.org/wiki/Command_pattern>`_ and give a concrete class to each action that can be taken on a web service.

Instantiating web service clients using a ServiceBuilder
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The best way to instantiate Guzzle web service clients is to let Guzzle handle building the clients for you using a ServiceBuilder.       A ServiceBuilder is responsible for creating concrete client objects based on configuration settings and helps to manage credentials  for different environments.

A ServiceBuilder can source information from an array, an XML file, SimpleXMLElement, or JSON file::

    <?php
    // Source service definitions from a JSON file
    $builder = ServiceBuilder::factory('services.json');

Clients are referenced using a customizable name you provide in your service definition.  The ServiceBuilder is a sort of multiton object-- it will only instantiate a client once and return that client for subsequent retrievals.  You can get a "throwaway" client (a client that is not persisted by the ServiceBuilder) by passing ``TRUE`` in the second argument of ``ServiceBuilder::get()``.

Here's an example of retrieving an Unfuddle client from your ServiceBuilder::

    <?php
    $client = $builder->get('unfuddle');
    // You can also use the ServiceBuilder object as an array
    $client = $builder['unfuddle'];

Sourcing data from XML
^^^^^^^^^^^^^^^^^^^^^^

A ServiceBuilder can get information from an XML file or a SimpleXMLElement.  The XML file includes ``<client>`` elements that describe each web service client you will use.  Parameters need to be specified in each ``<client>`` element to tell a ``Guzzle\Service\Builder\ServiceBuilder`` object how to build the web service client.  Clients are given names which are handy for using multiple accounts for the same service or creating development clients vs. production clients.  Here's an example of a services.xml that uses several `Amazon Web Services <http://aws.amazon.com/>`_ clients and the `Unfuddle <http://www.unfuddle.com/>`_ web service:

.. code-block:: xml

    <?xml version="1.0" ?>
    <guzzle>
        <clients>
            <!-- Abstract service to store AWS account credentials -->
            <client name="abstract.aws">
                <param name="access_key" value="12345" />
                <param name="secret_key" value="abcd" />
            </client>
            <!-- Amazon S3 client that extends the abstract client -->
            <client name="s3" classs="Guzzle.Aws.S3.S3Client" extends="abstract.aws">
                <param name="devpay_product_token" value="XYZ" />
                <param name="devpay_user_token" value="123" />
            </client>
            <client name="simple_db" class="Guzzle.Aws.SimpleDb.SimpleDbClient" extends="abstract.aws" />
            <client name="sqs" class="Guzzle.Aws.Sqs.SqsClient" extends="abstract.aws" />
            <!-- Unfuddle client -->
            <client name="unfuddle" class="Guzzle.Unfuddle.UnfuddleClient">
                <param name="username" value="test-user" />
                <param name="password" value="my-password" />
                <param name="subdomain" value="my-subdomain" />
            </client>
        </clients>
    </guzzle>

Let's dissect what's going on in the above XML file.  The first client defined, ``abstract.aws``, is an **abstract client** that can be used by other clients to share configuration values among a number of clients.  This can be useful when clients share the same username and password (i.e. Amazon Web Services).

The next client is an Amazon S3 client.  Each ``<client>`` nodes must contain a ``class`` attribute that references the full class name of the client being created (you can substitute PHP's namespace separator, ``\``, with a period ``.``).  Client nodes can inherit parameters from other previously defined nodes.  The above Amazon S3 client is inheriting configuration settings from the abstract.aws client and adding `Amazon DevPay <http://aws.amazon.com/devpay/>`_ related parameters.  As you can see from the `Amazon SimpleDB <http://aws.amazon.com/simpledb/>`_ and `Amazon SQS <http://aws.amazon.com/sqs/>`_ clients, not all clients will require additional parameters.

Sourcing from an Array
^^^^^^^^^^^^^^^^^^^^^^

Web service clients can be defined using an array of data.::

    <?php
    $builder = ServiceBuilder::factory(array(
        'aws' => array(
            'access_key' => 'xyz',
            'secret'     => 'abc'
        ),
        's3' => array(
            'class'   => 'Guzzle\\Aws\\S3\\S3Client',
            'extends' => 'aws',
            'params'  => array(
                'subdomain' => 'michael',
            ),
        ),
        'unfuddle' => array(
            'class'  => 'Guzzle\\Unfuddle\\UnfuddleClient',
            'params' => array(
                'username'  => 'test-user',
                'password'  => 'test-password',
                'subdomain' => 'test'
            )
        )
    ));

Caching parsed data
^^^^^^^^^^^^^^^^^^^

The interpreted data created from parsing a configuration file (.js, .json, or .xml) can be cached for faster subsequent access.  It is recommended that you cache the parsed configuration data by supplying a CacheAdapter to the ServiceBuilder::factory() method::

    <?php

    use Doctrine\Common\Cache\ApcCache;
    use Guzzle\Common\CacheAdapter\DoctrineCacheAdapter;
    use Guzzle\Service\Builder\ServiceBuilder;

    $cacheAdapter = new DoctrineCacheAdapter(new ApcCache());
    $builder = ServiceBuilder::factory('/path/to/services.xml', $cacheAdapter);

..

    An instantiated ServiceBuilder should now be used throughout the  execution of your script (possibly using a `registry      <http://martinfowler.com/eaaCatalog/registry.html>`_ or `multiton pattern <http://en.wikipedia.org/wiki/Multiton_pattern>`_).

Using Client objects
--------------------

Web service clients are the central point of interaction with a web service.  They hold service configuration data and help to ready HTTP requests to be sent to a web service.  Web service clients don't know much about the service itself-- they just execute commands.  Configuration settings can be retrieved from a client by passing a configuration key to the ``getConfig()`` method of a client (e.g. ``$token = $client->getConfig('devpay_product_token')``).

Executing commands using a client
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Commands are used to take action on a web service and format the response from the web service into something useful.  Commands can send single HTTP requests or send a complex series of requests to a web service.

Commands can be instantiated and configured by a client by calling the ``getCommand()`` method on a client and using the short form of a command's name.  The short form of a command's name is calculated based on the folder hierarchy of a command and converting the CamelCased named commands into snake_case.  Here are some examples on how the command names are calculated:

#. ``Guzzle\Aws\S3\Command\Bucket\ListBucket`` **->** bucket.list_bucket
#. ``Guzzle\Aws\S3\Command\GetAcl`` **->** get_acl
#. ``Guzzle\Unfuddle\Command\People\GetCurrentPerson`` **->** people.get_current_person

Notice how any sub-namespace beneath ``Command`` is converted from ``\`` to ``.`` (a period).  CamelCasing is converted to lowercased snake_casing (e.g. GetAcl == get_acl).

Here's how you would get the Amazon S3 client from the ServiceBuilder and execute a GetObject command to retrieve an object from Amazon S3::

    <?php

    // Retrieve the client by name
    $client = $serviceBuilder['s3'];

    $command = $client->getCommand('bucket.get_bucket');
    $command->setBucket('mybucket')->setKey('mykey');

    // The result of the GetObject command returns a Guzzle\Http\Message\Response object
    $httpResponse = $client->execute($command);

    // Get the body of the Amazon S3 object
    echo $httpResponse->getBody();

The GetObject command just returns the HTTP response object when it is executed.  This is the default behavior of Guzzle commands unless specified otherwise in the docblock of the ``getResult()`` method of a specific command.  Commands don't have to just return the HTTP response; commands might return more valuable information when executed::

    <?php

    // Get a command from the Amazon S3 client
    $command = $client->getCommand('bucket.list_bucket');
    $command->setBucket('mybucket');

    // Execute the command and get a BucketIterator object
    $objects = $client->execute($command);

    // Iterate over every single object in the bucket.  Subsequent requests
    // will be issued to retreive the next result of a truncated response.
    foreach ($objects as $object) {
        echo "{$object['key']} {$object['size']}\n";
    }

    // You can get access to the HTTP request issued by the command and the response
    echo $command->getRequest();
    echo $command->getResponse();

The ListBucket command above returns a ``Guzzle\Aws\S3\Model\BucketIterator`` which will iterate over the entire contents of a bucket.  Note: Don't use this command blindly-- unless you specify a limit, it will iterate over every page of results from AWS, which could be a large number of requests.

You can take some shortcuts in your code by passing key-value pair arguments to a command::

    <?php
    $objects = $client->getCommand('bucket.list_bucket', array('bucket' => 'my_bucket'))->execute();

Executing commands in parallel using CommandSets
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Commands can be sent in parallel using ``Guzzle\Service\Command\CommandSet`` objects::

    <?php

    use Guzzle\Http\Pool\PoolRequestException;
    use Guzzle\Service\Command\CommandSet;
    use Guzzle\Service\Command\CommandSetException;

    // Get an Amazon SimpleDB client from the ServiceBuilder
    $client = $serviceBuilder['simple_db'];

    // Create a CommandSet that will contain 3 commands
    $set = new CommandSet(array(
        $client->getCommand('get_attributes', array(
            'domain' => 'test',
            'item_name' => 'item1'
        )),
        $client->getCommand('get_attributes', array(
            'domain' => 'test',
            'item_name' => 'item2'
        )),
        $client->getCommand('delete_domain', array(
            'domain' => 'test_2'
        ))
    ));

    try {
        $client->execute($set);
        foreach ($set as $command) {
            echo $command->getName . ': ' . $command->getResponse()->getStatusCode() . "\n";
        }
    } catch (PoolRequestException $e) {
        // Exceptions encountered while transferring commands in a Pool will be
        // aggregated into one iterable exception
        foreach ($e as $exception) {
            echo $exception->getMessage();
        }
    } catch (\Exception $e) {
        echo $e->getMessage();
    }

Guzzle doesn't require that all of the commands in a CommandSet originate from the same client.  This allows you to write extremely efficient code when you need to send several requests to multiple services::

    <?php

    use Guzzle\Service\Command\CommandSet;

    // Get all of the commands from a registered client object
    $set = new CommandSet(array(
        $serviceBuilder['simple_db']->getCommand('get_attributes', array(
            'domain' => 'test',
            'item_name' => 'item1'
        )),
        $serviceBuilder['s3']->getCommand('bucket.head_bucket', array(
            'bucket' => 'my_bucket'
        )),
        $serviceBuilder['unfuddle']->getCommand('people.get_current_person'),
    ));

    $set->execute();

    foreach ($set as $command) {
        // Do something with the results of each command
        switch ($command->getName()) {
            case 'get_attributes':
                break;
            case 'bucket.head_bucket':
                break;
            case 'people.get_current_person':
                break;
        }
    }

Non-Batchable commands
^^^^^^^^^^^^^^^^^^^^^^

Some commands cannot be sent in parallel (i.e. ``Guzzle\Aws\S3\Command\Bucket\ClearBucket``).  These types of commands have the canBatch attribute on them set to FALSE and cannot be sent in parallel using a CommandSet.  When a CommandSet contains both batchable and non-batchable commands, the CommandSet will first execute the non-batchable commands serially followed by the batchable commands in parallel.

Adding observers to Client objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Any observer attached to the ``EventManager`` of a ``Client`` object will automatically be attached to all request objects created by the client.  This allows you to attach, for example, an ExponentialBackoffPlugin to a client object, and from that point on, every request sent through that client will utilize the ExponentialBackoffPlugin.  Plugins that are required for services are usually attached to a client in the client's factory method.  For example, all AWS clients will use the ExponentialBackoffPlugin.  In this case, you will not need to attach it again::

    <?php

    use Doctrine\Common\Cache\ArrayCache;
    use Guzzle\Common\Cache\DoctrineCacheAdapter;
    use Guzzle\Http\Plugin\CachePlugin;

    $client = $serviceBuilder->get('s3');

    // Attach a CachePlugin to the client
    $client->getEventManager()->attach(
        new CachePlugin(new DoctrineCacheAdapter(new ArrayCache()), true)
    );

    $request = $client->get();

The ``$request`` will use the CachePlugin because the CachePlugin was attached to the Client.

Next steps
~~~~~~~~~~

Check the documentation of the web service client you are using to see the available commands for the client.  Some clients will mix :doc:`dynamic commands </guide/service/creating_dynamic_commands>` with concrete commands, so might need to check if an XML file is shipped with the client that defines dynamic commands that can be executed on a web service.